<html>

<head>
  <title>INFO 3300 - Project 1</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    .legend span {
      margin-right: 10px;
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>

</head>

<body>
  <div class="container larger">

    <svg id="barchart" height="400" width="600">
    </svg>

    <svg id="barchart1" height="400" width="600">
    </svg>

    <svg id="scatterplot" height="400" width="600" style="margin-top:50px">
      <text id="label" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
    </svg>

    <script>

      const svg_bar = d3.select("svg#barchart");
      const svg_bar1 = d3.select("svg#barchart1");

      const svg = d3.select("svg#scatterplot");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 10, right: 10, bottom: 50, left: 50 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", "annotations");
      let chartArea = svg.append("g").attr("id", "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Import CSV data (nested)
      d3.csv("Public_Recycling_Bins.csv", d3.autoType)
        .then((data1) => {

          let bronx = 0;
          let queens = 0;
          let manhattan = 0;
          let brooklyn = 0;
          let staten_island = 0;
          data1.forEach(function (d) {
            if (d.Borough == 'Bronx') {
              bronx++;
            }
            else if (d.Borough == 'Queens') {
              queens++;
            }
            else if (d.Borough == 'Manhattan') {
              manhattan++;
            }
            else if (d.Borough == 'Brooklyn') {
              brooklyn++;
            }
            else {
              staten_island++;
            }
          });

          d3.csv("Recycling_Diversion_and_Capture_Rates.csv", d3.autoType)
            .then((data2) => {

              let bronx_recycling = 0;
              let queens_recycling = 0;
              let manhattan_recycling = 0;
              let brooklyn_recycling = 0;
              let staten_island_recycling = 0;
              data2.forEach(function (d) {
                if (d.Zone == 'Bronx') {
                  bronx_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
                }
                else if (d.Zone == 'Queens') {
                  queens_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
                }
                else if (d.Zone == 'Manhattan') {
                  manhattan_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
                }
                else if (d.Zone == 'Brooklyn') {
                  brooklyn_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
                }
                else {
                  staten_island_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
                }
              });

              console.log("bronx: " + bronx);
              console.log("queens: " + queens);
              console.log("m:" + manhattan);
              console.log("b:" + brooklyn);
              console.log("si:" + staten_island);

              number_bins_per_bur = [{ 'bronx': 'br', 'pop': bronx }, { 'queens': 'q', 'pop': queens }, { 'manhattan': 'm', 'pop': manhattan }, { 'brooklyn': 'brook', 'pop': brooklyn }, { 'staten_island': 'si', 'pop': staten_island }];

              console.log("bronx_r: " + bronx_recycling);
              console.log("queens_r: " + queens_recycling);
              console.log("m_r:" + manhattan_recycling);
              console.log("b_r:" + brooklyn_recycling);
              console.log("si_r:" + staten_island_recycling);

              d3.csv("New_York_City_Population_by_Borough__1950_-_2040.csv", d3.autoType)
                .then((data3) => {

                  const popExtent = d3.extent(data3, d => d['2020']);
                  const popScale = d3.scaleLinear().domain(popExtent).range([10, chartWidth]);

                  const binsExtent = d3.extent([bronx, queens, manhattan, brooklyn, staten_island]);
                  const binsScale = d3.scaleLinear().domain(binsExtent).range([10, chartWidth]);

                  data3.forEach((d, i) => {
                    svg_bar.append("line")
                      .attr("x1", popScale(d['2020']))
                      .attr("x2", popScale(d['2020']))
                      .attr("y1", height / 2)
                      .attr("y2", height / 2 - popScale(d['2020']))
                      .style("stroke", "#5555F0")
                      .style("stroke-width", 20)
                      .style("padding", 10);

                    svg_bar.append("text")
                      .attr("text-anchor", "middle")
                      .attr("font-size", "10px")
                      .attr("x", popScale(d['2020']))
                      .attr('y', 100)
                      .text(d['2020']);
                  });

                  number_bins_per_bur.forEach((d, i) => {
                    svg_bar1.append("line")
                      .attr("x1", binsScale(d['pop']))
                      .attr("x2", binsScale(d['pop']))
                      .attr("y1", height / 2)
                      .attr("y2", height / 2 - binsScale(d['pop']))
                      .style("stroke", "#5555F0")
                      .style("stroke-width", 20)
                      .style("padding", 10);

                    svg_bar1.append("text")
                      .attr("text-anchor", "middle")
                      .attr("font-size", "10px")
                      .attr("x", binsScale(d['pop']))
                      .attr('y', 100)
                      .text(d['pop']);
                  });

                  // Scales
                  // const yearExtent = d3.extent(data, d => d['year']);
                  // const yearScale = d3.scaleLinear().domain(yearExtent).range([0, chartWidth]);
                  // const grossExtent = d3.extent(data, d => d['worldwide_gross']);
                  // const grossScale = d3.scaleLog().domain(grossExtent).range([chartHeight, 0]);
                  // const imdbExtent = d3.extent(data, d => d['imdb_rating']);
                  // const imdbScale = d3.scaleLinear().domain(imdbExtent).range([3, 8]);
                  // const genreScale = d3.scaleOrdinal(d3.schemeCategory10);

                  // Y axis
                  let leftAxis = d3.axisLeft(grossScale)
                    .tickFormat(d3.format("$.0s"))
                  let leftGridlines = d3.axisLeft(grossScale)
                    .tickSize(-chartWidth - 10)
                    .tickFormat("")
                  annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
                    .call(leftAxis)
                  annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
                    .call(leftGridlines);

                  // X axis
                  let bottomAxis = d3.axisBottom(yearScale)
                    .tickFormat(d3.format("~f"));
                  let bottomGridlines = d3.axisBottom(yearScale)
                    .tickSize(-chartHeight - 10)
                    .tickFormat("")
                  annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
                    .call(bottomAxis);
                  annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
                    .call(bottomGridlines);
                });
            });
        });

    </script>

  </div>
</body>

</html>