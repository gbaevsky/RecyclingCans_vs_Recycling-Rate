<html>

<head>
  <title>INFO 3300 - Project 1</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    .legend span {
      margin-right: 10px;
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>

</head>

<body>
  <div class="container larger">

    <svg id="barchart" height="400" width="600" style="background: #F5F5FF">
    </svg>

    <svg id="barchart1" height="400" width="600">
    </svg>

    <svg id="scatterplot" height="400" width="600" style="margin-top:50px">
      <text id="label" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
    </svg>

    <script>

      const svg_bar = d3.select("svg#barchart");
      const svg_bar1 = d3.select("svg#barchart1");

      const svg = d3.select("svg#scatterplot");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 10, right: 10, bottom: 50, left: 50 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      let annotations = svg.append("g").attr("id", "annotations");
      let chartArea = svg.append("g").attr("id", "points")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Import CSV data using async function

      const dataFunc = async function () {
        // d3.csv("Public_Recycling_Bins.csv", d3.autoType)
        //   .then((data1) => {

        // d3.csv("Recycling_Diversion_and_Capture_Rates.csv", d3.autoType)
        //     .then((data2) => {

        // d3.csv("New_York_City_Population_by_Borough__1950_-_2040.csv", d3.autoType)
        //         .then((data3) => {

        const data1 = await d3.csv("Public_Recycling_Bins.csv", d3.autoType);
        const data2 = await d3.csv("Recycling_Diversion_and_Capture_Rates.csv", d3.autoType);
        const data3 = await d3.csv("New_York_City_Population_by_Borough__1950_-_2040.csv", d3.autoType);

        let bronx = 0;
        let queens = 0;
        let manhattan = 0;
        let brooklyn = 0;
        let staten_island = 0;
        data1.forEach(function (d) {
          if (d.Borough == 'Bronx') {
            bronx++;
          }
          else if (d.Borough == 'Queens') {
            queens++;
          }
          else if (d.Borough == 'Manhattan') {
            manhattan++;
          }
          else if (d.Borough == 'Brooklyn') {
            brooklyn++;
          }
          else {
            staten_island++;
          }
        });


        let bronx_recycling = 0;
        let queens_recycling = 0;
        let manhattan_recycling = 0;
        let brooklyn_recycling = 0;
        let staten_island_recycling = 0;
        data2.forEach(function (d) {
          if (d.Zone == 'Bronx') {
            bronx_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else if (d.Zone == 'Queens') {
            queens_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else if (d.Zone == 'Manhattan') {
            manhattan_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else if (d.Zone == 'Brooklyn') {
            brooklyn_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else {
            staten_island_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
        });

        console.log("bronx: " + bronx);
        console.log("queens: " + queens);
        console.log("m:" + manhattan);
        console.log("b:" + brooklyn);
        console.log("si:" + staten_island);

        number_bins_per_bur = [{ 'bronx': 'br', 'pop': bronx }, { 'queens': 'q', 'pop': queens }, { 'manhattan': 'm', 'pop': manhattan }, { 'brooklyn': 'brook', 'pop': brooklyn }, { 'staten_island': 'si', 'pop': staten_island }];

        console.log("bronx_r: " + bronx_recycling);
        console.log("queens_r: " + queens_recycling);
        console.log("m_r:" + manhattan_recycling);
        console.log("b_r:" + brooklyn_recycling);
        console.log("si_r:" + staten_island_recycling);


        // BAR CHARTS

        const popExtent = d3.extent(data3, d => d['2020']);
        const popScale = d3.scaleLinear().domain(popExtent).range([50, width - 10]);

        percentScale = d3.scaleLinear()
          .domain([0, 1])
          .range([height - 10, 30]);

        let colorScale = d3.scaleLinear()
          .domain([0, 1])
          .range(['navy', 'turquoise'])
          .interpolate(d3.interpolateHcl);

        svg_bar.append("text").text("Population by Borough").attr("x", 10).attr("y", 20).style("font-size", "15px");

        data3.forEach((d, i) => {
          svg_bar.append("line")
            .attr("x1", popScale(d['2020']))
            .attr("x2", popScale(d['2020']))
            .attr("y1", height - 10)
            .attr("y2", height - popScale(d['2020']))
            .style("stroke", colorScale(d['2020']))
            .style("stroke-width", 10);

          svg_bar.append("text")
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("x", popScale(d['2020']))
            .attr('y', popScale(d['2020']) + 50)
            .text(d['Borough'] + ': ' + d['2020']);
        });

        const binsExtent = d3.extent([bronx, queens, manhattan, brooklyn, staten_island]);
        const binsScale = d3.scaleLinear().domain(binsExtent).range([10, chartWidth]);

        // number_bins_per_bur.forEach((d, i) => {
        //   svg_bar1.append("line")
        //     .attr("x1", binsScale(d['pop']))
        //     .attr("x2", binsScale(d['pop']))
        //     .attr("y1", height / 2)
        //     .attr("y2", height / 2 - binsScale(d['pop']))
        //     .style("stroke", "#5555F0")
        //     .style("stroke-width", 20)
        //     .style("padding", 10);

        //   svg_bar1.append("text")
        //     .attr("text-anchor", "middle")
        //     .attr("font-size", "10px")
        //     .attr("x", binsScale(d['pop']))
        //     .attr('y', 100)
        //     .text(d['pop']);
        // });



        // SCATTERPLOT

        // Scales
        // const yearExtent = d3.extent(data, d => d['year']);
        // const yearScale = d3.scaleLinear().domain(yearExtent).range([0, chartWidth]);
        // const grossExtent = d3.extent(data, d => d['worldwide_gross']);
        // const grossScale = d3.scaleLog().domain(grossExtent).range([chartHeight, 0]);
        // const imdbExtent = d3.extent(data, d => d['imdb_rating']);
        // const imdbScale = d3.scaleLinear().domain(imdbExtent).range([3, 8]);
        // const genreScale = d3.scaleOrdinal(d3.schemeCategory10);

        // Y axis
        // let leftAxis = d3.axisLeft(grossScale)
        //   .tickFormat(d3.format("$.0s"))
        // let leftGridlines = d3.axisLeft(grossScale)
        //   .tickSize(-chartWidth - 10)
        //   .tickFormat("")
        // annotations.append("g")
        //   .attr("class", "y axis")
        //   .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        //   .call(leftAxis)
        // annotations.append("g")
        //   .attr("class", "y gridlines")
        //   .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        //   .call(leftGridlines);

        // X axis
        // let bottomAxis = d3.axisBottom(yearScale)
        //   .tickFormat(d3.format("~f"));
        // let bottomGridlines = d3.axisBottom(yearScale)
        //   .tickSize(-chartHeight - 10)
        //   .tickFormat("")
        // annotations.append("g")
        //   .attr("class", "x axis")
        //   .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        //   .call(bottomAxis);
        // annotations.append("g")
        //   .attr("class", "x gridlines")
        //   .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        //   .call(bottomGridlines);
      };

      dataFunc();

    </script>

  </div>
</body>

</html>