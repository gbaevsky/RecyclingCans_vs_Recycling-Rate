<html>

<head>
  <title>INFO 3300 - Project 1</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    .legend span {
      margin-right: 10px;
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>

</head>

<body>
  <div class="container larger">

    <svg id="barchart" height="400" width="600" style="background: #F5F5FF">
    </svg>

    <svg id="scatterplot" height="400" width="600" style="margin-top:50px">
      <text id="label" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
    </svg>

    <script>

      const svg = d3.select("svg#scatterplot");

      const svg_bar = d3.select("svg#barchart");

      const width = svg_bar.attr("width");
      const height = svg_bar.attr("height");
      const margin = { top: 50, right: 10, bottom: 50, left: 50 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      let annotations = svg_bar.append("g").attr("id", "annotations");
      let chartArea = svg_bar.append("g").attr("id", "points")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // let annotations = svg.append("g").attr("id", "annotations");
      // let chartArea = svg.append("g").attr("id", "points")
      //   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Import CSV data using async function

      const dataFunc = async function () {
        // d3.csv("Public_Recycling_Bins.csv", d3.autoType)
        //   .then((data1) => {

        // d3.csv("Recycling_Diversion_and_Capture_Rates.csv", d3.autoType)
        //     .then((data2) => {

        // d3.csv("New_York_City_Population_by_Borough__1950_-_2040.csv", d3.autoType)
        //         .then((data3) => {

        const data1 = await d3.csv("Public_Recycling_Bins.csv", d3.autoType);
        const data2 = await d3.csv("Recycling_Diversion_and_Capture_Rates.csv", d3.autoType);
        const data3 = await d3.csv("New_York_City_Population_by_Borough.csv", d3.autoType);

        let bronx = 0;
        let queens = 0;
        let manhattan = 0;
        let brooklyn = 0;
        let staten_island = 0;
        data1.forEach(function (d) {
          if (d.Borough == 'Bronx') {
            bronx++;
          }
          else if (d.Borough == 'Queens') {
            queens++;
          }
          else if (d.Borough == 'Manhattan') {
            manhattan++;
          }
          else if (d.Borough == 'Brooklyn') {
            brooklyn++;
          }
          else {
            staten_island++;
          }
        });


        let bronx_recycling = 0;
        let queens_recycling = 0;
        let manhattan_recycling = 0;
        let brooklyn_recycling = 0;
        let staten_island_recycling = 0;
        data2.forEach(function (d) {
          if (d.Zone == 'Bronx') {
            bronx_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else if (d.Zone == 'Queens') {
            queens_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else if (d.Zone == 'Manhattan') {
            manhattan_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else if (d.Zone == 'Brooklyn') {
            brooklyn_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
          else {
            staten_island_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          }
        });

        console.log("bronx: " + bronx);
        console.log("queens: " + queens);
        console.log("m:" + manhattan);
        console.log("b:" + brooklyn);
        console.log("si:" + staten_island);

        number_bins_per_bur = [{ 'bronx': 'br', 'pop': bronx }, { 'queens': 'q', 'pop': queens }, { 'manhattan': 'm', 'pop': manhattan }, { 'brooklyn': 'brook', 'pop': brooklyn }, { 'staten_island': 'si', 'pop': staten_island }];

        console.log("bronx_r: " + bronx_recycling);
        console.log("queens_r: " + queens_recycling);
        console.log("m_r:" + manhattan_recycling);
        console.log("b_r:" + brooklyn_recycling);
        console.log("si_r:" + staten_island_recycling);


        // BAR CHART

        const bur = d3.map(data3, d => d['Borough']);
        const burScale = d3.scaleBand().domain(bur).range([0, chartWidth]).padding(0.05);

        let bottomAxis = d3.axisBottom(burScale)
        annotations.append("g")
          .attr("class", "x axis")
          .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
          .call(bottomAxis);

        const popExtent = d3.extent(data3, d => d['2020']);
        const popScale = d3.scaleLinear().domain(popExtent).range([chartHeight - 60, 0]);

        let colorScale = d3.scaleLinear()
          .domain([0, 1])
          .range(['navy', 'turquoise'])
          .interpolate(d3.interpolateHcl);

        svg_bar.append("text").text("Population by Borough").attr("x", 10).attr("y", 20).style("font-size", "15px");

        chartArea.selectAll('rect.bar').data(data3)
          .join('rect')
          .attr('class', 'bar')
          .attr("fill", "black")
          .attr("x", d => burScale(d['Borough']))
          .attr("y", d => popScale(d['2020']))
          .attr("height", d => chartHeight - popScale(d['2020']))
          .attr("width", burScale.bandwidth());

        chartArea.selectAll('text.bar').data(data3)
          .join('text')
          .attr('class', 'bar')
          .attr("text-anchor", "middle")
          .attr("font-size", "10px")
          .attr("x", d => burScale(d['Borough']) + 50)
          .attr('y', d => popScale(d['2020']) - 10)
          .text(d => d['2020']);

        // const binsExtent = d3.extent([bronx, queens, manhattan, brooklyn, staten_island]);
        // const binsScale = d3.scaleLinear().domain(binsExtent).range([10, chartWidth]);

        // SCATTERPLOT

        // Scales
        // const yearExtent = d3.extent(data, d => d['year']);
        // const yearScale = d3.scaleLinear().domain(yearExtent).range([0, chartWidth]);
        // const grossExtent = d3.extent(data, d => d['worldwide_gross']);
        // const grossScale = d3.scaleLog().domain(grossExtent).range([chartHeight, 0]);
        // const imdbExtent = d3.extent(data, d => d['imdb_rating']);
        // const imdbScale = d3.scaleLinear().domain(imdbExtent).range([3, 8]);
        // const genreScale = d3.scaleOrdinal(d3.schemeCategory10);

        // Y axis
        // let leftAxis = d3.axisLeft(grossScale)
        //   .tickFormat(d3.format("$.0s"))
        // let leftGridlines = d3.axisLeft(grossScale)
        //   .tickSize(-chartWidth - 10)
        //   .tickFormat("")
        // annotations.append("g")
        //   .attr("class", "y axis")
        //   .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        //   .call(leftAxis)
        // annotations.append("g")
        //   .attr("class", "y gridlines")
        //   .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        //   .call(leftGridlines);

        // X axis
        // let bottomAxis = d3.axisBottom(yearScale)
        //   .tickFormat(d3.format("~f"));
        // let bottomGridlines = d3.axisBottom(yearScale)
        //   .tickSize(-chartHeight - 10)
        //   .tickFormat("")
        // annotations.append("g")
        //   .attr("class", "x axis")
        //   .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        //   .call(bottomAxis);
        // annotations.append("g")
        //   .attr("class", "x gridlines")
        //   .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        //   .call(bottomGridlines);
      };

      dataFunc();

    </script>

  </div>
</body>

</html>