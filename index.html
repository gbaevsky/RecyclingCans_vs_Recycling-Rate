<html>

<head>
  <title>INFO 3300 - Project 1</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    .legend span {
      margin-right: 10px;
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>

</head>

<body>

  <svg id="barchart" height="400" width="600" style="background: #F5F5FF">
  </svg>

  <svg id="barchart1" height="400" width="600" style="background: #F5F5FF">
  </svg>

  <svg id="scatterplot1" height="400" width="600" style="margin-top:50px">
    <text id="label_scatter_1" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
  </svg>

  <svg id="scatterplot2" height="400" width="600" style="margin-top:50px">
    <text id="label_scatter_2" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
  </svg>

  <script>

    const svg_bar = d3.select("svg#barchart");

    const width = svg_bar.attr("width");
    const height = svg_bar.attr("height");
    const margin = { top: 50, right: 10, bottom: 50, left: 50 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    let annotations = svg_bar.append("g").attr("id", "annotations");
    let chartArea = svg_bar.append("g").attr("id", "points")
      .attr("transform", `translate(${margin.left},${margin.top})`);



    const svg_bar1 = d3.select("svg#barchart1");

    let annotations1 = svg_bar1.append("g").attr("id", "annotations");
    let chartArea1 = svg_bar1.append("g").attr("id", "points")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // let annotations = svg.append("g").attr("id", "annotations");
    // let chartArea = svg.append("g").attr("id", "points")
    //   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Import CSV data using async function

    const dataFunc = async function () {
      const data1 = await d3.csv("Public_Recycling_Bins.csv", d3.autoType);
      const data2 = await d3.csv("Recycling_Diversion_and_Capture_Rates.csv", d3.autoType);
      const data3 = await d3.csv("New_York_City_Population_by_Borough.csv", d3.autoType);

      let bronx = 0;
      let queens = 0;
      let manhattan = 0;
      let brooklyn = 0;
      let staten_island = 0;
      data1.forEach(function (d) {
        if (d.Borough == 'Bronx') {
          bronx++;
        }
        else if (d.Borough == 'Queens') {
          queens++;
        }
        else if (d.Borough == 'Manhattan') {
          manhattan++;
        }
        else if (d.Borough == 'Brooklyn') {
          brooklyn++;
        }
        else {
          staten_island++;
        }
      });

      let bronx_recycling = 0;
      let bronx_zones = 0;
      let queens_recycling = 0;
      let queens_zones = 0;
      let manhattan_recycling = 0;
      let manhattan_zones = 0;
      let brooklyn_recycling = 0;
      let brooklyn_zones = 0;
      let staten_island_recycling = 0;
      let staten_island_zones = 0;
      data2.forEach(function (d) {
        if (d.Zone == 'Bronx') {
          bronx_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          bronx_zones++;
        }
        else if (d.Zone == 'Queens') {
          queens_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          queens_zones++;
        }
        else if (d.Zone == 'Manhattan') {
          manhattan_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          manhattan_zones++;
        }
        else if (d.Zone == 'Brooklyn') {
          brooklyn_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          brooklyn_zones++;
        }
        else {
          staten_island_recycling += d["Diversion Rate-Total (Total Recycling / Total Waste)"];
          staten_island_zones++;
        }
      });

      let bronx_pop = 0;
      let queens_pop = 0;
      let manhattan_pop = 0;
      let brooklyn_pop = 0;
      let staten_island_pop = 0;
      data3.forEach(function (d) {
        let pop = d['2020'];
        if (d.Borough == '   Bronx') {
          bronx_pop = pop;
        }
        else if (d.Borough == '   Queens') {
          queens_pop = d['2020'];
        }
        else if (d.Borough == '   Manhattan') {
          manhattan_pop = d['2020'];
        }
        else if (d.Borough == '   Brooklyn') {
          brooklyn_pop = d['2020'];
        }
        else {
          staten_island_pop = d['2020'];
        }
      });

      recycling_data = [{ borough: "Bronx", bins: bronx, population: bronx_pop, avg_recycling: bronx_recycling / bronx_zones },
      { borough: "Queens", bins: queens, population: queens_pop, avg_recycling: queens_recycling / queens_zones },
      { borough: "Manhattan", bins: manhattan, population: manhattan_pop, avg_recycling: manhattan_recycling / manhattan_zones },
      { borough: "Brooklyn", bins: brooklyn, population: brooklyn_pop, avg_recycling: brooklyn_recycling / brooklyn_zones },
      { borough: "Staten Island", bins: staten_island, population: staten_island_pop, avg_recycling: staten_island_recycling / staten_island_zones }];
      console.log(recycling_data);

      // BAR CHART

      const bur = d3.map(data3, d => d['Borough']);
      const burScale = d3.scaleBand().domain(bur).range([0, chartWidth]).padding(0.05);

      let bottomAxis = d3.axisBottom(burScale)
      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
        .call(bottomAxis);

      const popExtent = d3.extent(data3, d => d['2020']);
      const popScale = d3.scaleLinear().domain(popExtent).range([chartHeight - 60, 0]);

      const colorScale = d3.scaleOrdinal().domain(['Bronx', 'Brooklyn', 'Manhattan', 'Queens', 'Staten Island'])
        .range(['blue', 'green', 'red', 'purple', 'cyan']);

      svg_bar.append("text").text("Population by Borough").attr("x", 10).attr("y", 20).style("font-size", "25px");

      chartArea.selectAll('rect.bar').data(data3)
        .join('rect')
        .attr('class', 'bar')
        .attr("fill", d => colorScale(d['Borough']))
        .attr("x", d => burScale(d['Borough']))
        .attr("y", d => popScale(d['2020']))
        .attr("opacity", 0.2)
        .attr("height", d => chartHeight - popScale(d['2020']))
        .attr("width", burScale.bandwidth());

      chartArea.selectAll('text.bar').data(data3)
        .join('text')
        .attr('class', 'bar')
        .attr("text-anchor", "middle")
        .attr("font-size", "15px")
        .attr("x", d => burScale(d['Borough']) + 50)
        .attr('y', d => popScale(d['2020']) - 10)
        .text(d => d['2020']);

      const bur1 = d3.map(recycling_data, d => d.borough);
      const burScale1 = d3.scaleBand().domain(bur1).range([0, chartWidth]).padding(0.05);

      let bottomAxis1 = d3.axisBottom(burScale1)
      annotations1.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
        .call(bottomAxis1);

      const binsExtent = d3.extent(recycling_data, d => d.bins);
      const binsScale = d3.scaleLinear().domain(binsExtent).range([chartHeight - 60, 0]);

      svg_bar1.append("text").text("Number of Public Recycling Bins by Borough").attr("x", 10).attr("y", 20).style("font-size", "25px");

      chartArea1.selectAll('rect.bar1').data(recycling_data)
        .join('rect')
        .attr('class', 'bar1')
        .attr("fill", d => colorScale(d.borough))
        .attr("x", d => burScale1(d.borough))
        .attr("y", d => binsScale(d.bins))
        .attr("opacity", 0.2)
        .attr("height", d => chartHeight - binsScale(d.bins))
        .attr("width", burScale1.bandwidth());

      chartArea1.selectAll('text.bar1').data(recycling_data)
        .join('text')
        .attr('class', 'bar1')
        .attr("text-anchor", "middle")
        .attr("font-size", "15px")
        .attr("x", d => burScale1(d.borough) + 50)
        .attr('y', d => binsScale(d.bins) - 10)
        .text(d => d.bins);

      // SCATTERPLOT 1: Recycling Rate vs Bins

      const svg_scatter_1 = d3.select("svg#scatterplot1");
      const scatter_width = svg_scatter_1.attr("width");
      const scatter_height = svg_scatter_1.attr("height");
      const scatterPixelWidth = scatter_width - margin.left - margin.right;
      const scatterPixelHeight = scatter_height - margin.top - margin.bottom;

      // Scales
      const binsExtentScatter = d3.extent(recycling_data, d => d.bins);
      binsExtentScatter[1] = binsExtentScatter[1] + 20; // give more space
      const binsScaleScatter = d3.scaleLinear().domain(binsExtentScatter).range([0, scatterPixelWidth]);

      const recyclingExtent = d3.extent(recycling_data, d => d.avg_recycling);
      const recyclingScale = d3.scaleLinear().domain(recyclingExtent).range([scatterPixelHeight, 0]);

      // const imdbExtent = d3.extent(data, d => d['imdb_rating']);
      // const imdbScale = d3.scaleLinear().domain(imdbExtent).range([3, 8]);
      // const genreScale = d3.scaleOrdinal(d3.schemeCategory10);

      svg_scatter_1.append("text").text("Recycling Rate vs Recycling Bins").attr("x", 10).attr("y", 20).style("font-size", "25px");
      // Y axis
      let leftAxisScatter1 = d3.axisLeft(recyclingScale)
      //  .tickFormat(d3.format("$.0s"))
      let leftGridlinesScatter1 = d3.axisLeft(recyclingScale)
        .tickSize(-scatterPixelWidth - 10)
        .tickFormat("")
      svg_scatter_1.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxisScatter1)
      svg_scatter_1.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlinesScatter1);

      // X axis
      let bottomAxisScatter1 = d3.axisBottom(binsScaleScatter)
        .tickFormat(d3.format("~f"));
      let bottomGridlinesScatter1 = d3.axisBottom(binsScaleScatter)
        .tickSize(-chartHeight - 10)
        .tickFormat("")
      svg_scatter_1.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        .call(bottomAxisScatter1);
      svg_scatter_1.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        .call(bottomGridlinesScatter1);

      svg_scatter_1.selectAll("circle").data(recycling_data)
        .join("circle")
        .attr("cx", d => (binsScaleScatter(d.bins) + margin.left))
        .attr("cy", d => (recyclingScale(d.avg_recycling) + margin.top))
        .attr("r", d => 5)
        .attr("fill", d => colorScale(d.borough))
        .attr("opacity", 0.8);

      svg_scatter_1.selectAll("text.scatter1").data(recycling_data)
        .join("text")
        .attr("x", d => (binsScaleScatter(d.bins) + margin.left))
        .attr("y", d => (recyclingScale(d.avg_recycling) + margin.top - 10))
        .attr('class', 'scatter1')
        .attr("text-anchor", "right")
        .text(d => d.borough)
        .style("font-size", "10px")
        .attr("opacity", 0.7);


      // SCATTERPLOT 2: Recycling Rate vs Bins per person
      const svg_scatter_2 = d3.select("svg#scatterplot2");

      // Scales
      const binsPerPersonExtentScatter = d3.extent(recycling_data, d => (d.bins / d.population));
      binsPerPersonExtentScatter[1] = binsPerPersonExtentScatter[1] + 0.00001; // give more space
      const binsPerPersonScaleScatter = d3.scaleLinear().domain(binsPerPersonExtentScatter).range([0, scatterPixelWidth]);

      // const imdbExtent = d3.extent(data, d => d['imdb_rating']);
      // const imdbScale = d3.scaleLinear().domain(imdbExtent).range([3, 8]);
      // const genreScale = d3.scaleOrdinal(d3.schemeCategory10);

      svg_scatter_2.append("text").text("Recycling Rate vs People per Recycling Bin").attr("x", 10).attr("y", 20).style("font-size", "25px");
      // Y axis
      // reusing scales from scatterplot 1:
      svg_scatter_2.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftAxisScatter1)
      svg_scatter_2.append("g")
        .attr("class", "y gridlines")
        .attr("transform", "translate(" + (margin.left - 10) + "," + margin.top + ")")
        .call(leftGridlinesScatter1);

      // X axis
      let bottomAxisScatter2 = d3.axisBottom(binsPerPersonScaleScatter)
        .tickFormat(d3.format("~f"));
      let bottomGridlinesScatter2 = d3.axisBottom(binsPerPersonScaleScatter)
        .tickSize(-chartHeight - 10)
        .tickFormat("")
      svg_scatter_2.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        .call(bottomAxisScatter2);
      svg_scatter_2.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin.left + "," + (chartHeight + margin.top + 10) + ")")
        .call(bottomGridlinesScatter2);

      svg_scatter_2.selectAll("circle").data(recycling_data)
        .join("circle")
        .attr("cx", d => (binsPerPersonScaleScatter(d.bins / d.population) + margin.left))
        .attr("cy", d => (recyclingScale(d.avg_recycling) + margin.top))
        .attr("r", d => 5)
        .attr("fill", d => colorScale(d.borough))
        .attr("opacity", 0.8);

      svg_scatter_2.selectAll("text.scatter2").data(recycling_data)
        .join("text")
        .attr("x", d => (binsPerPersonScaleScatter(d.bins / d.population) + margin.left))
        .attr("y", d => (recyclingScale(d.avg_recycling) + margin.top - 10))
        .attr('class', 'scatter1')
        .attr("text-anchor", "right")
        .text(d => d.borough)
        .style("font-size", "10px")
        .attr("opacity", 0.7);
    };

    dataFunc();

  </script>

</body>

</html>
